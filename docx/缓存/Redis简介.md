###Redis
####Redis常见数据类型
- Key：字符串类型
- Value
  - String：字符串，可用于存储String，Integer，Float型的数据，甚至二进制数据，最大512M。
     - 扩容机制：采用冗余空间方式来减少内存分配，小于等于1M时，加倍扩容，大于1M时，每次扩容1M。 
  - List:字符串List，底层实现是**双向链表**。 
  - Set：字符串Set，无序不可重复，底层实现HashTable.
  - Hash；按照k-v方式存放数据。
     - 采用渐进式rehash方案，同时保留新旧Hash结构，在后续定时任务以及操作中将旧数据移到新结构中，缩容也是如此。 
  - ZSet：快速set，有序不可重复，底层使用散列表和**跳跃表**实现，读取数据很快。
     ps:跳跃表的增删改查时间复杂度为log2n
     
####Redis为什么这么快？
- 基于内存操作
- 数据结构简单
- 采用单线程
   - 为什么是单线程？
   - Redis单线程已经很快了，没必要多线程增加额外复杂性，可以采用单机开多个Redis实例来发挥多核特效
- 使用多路复用IO模型

####Redis与Memcache区别
- M只支持简单的k-v形式，R支持更多
- M支持多线程，R单线程
- R支持持久化，M不支持

####Redis的过期淘汰机制
#####定时删除+惰性删除
- 定时删除：每隔一段时间，从选取一部分数据校验是否过期，如果超过25%过期，执行淘汰策略，再重新选取数据校验。。。。
- 惰性删除：当执行性多缓存命令或setnx命令时，会得该缓存进行校验

#####内存淘汰策略
- noeviction:内存达到阈值，任何申请内存的命令均报错
- allkeys-lru:在主键空间，优先删除最近未使用key
- volatile-lru:在设置了过期时间的的空间中，优先删除最近未使用的key
- allkeys-random:在主键空间中，随机删除key
- volatile-random:在设置了过期时间的的空间中，随机删除key
- volatile-ttl:在设置了过期时间的的空间中,具有更早过期时间的key删除

####Redis持久化方式
#####RDB快照
通过创建某个时间点的副本来持久化，RDB文件可同步到其他服务器上。

- 简单过程：fork子进程->将数据写入临时文件->临时文件替换老文件
- 触发过程：
   - 手动触发：save命令和bgsave命令
      - save:会使Redis处于阻塞状态，直到RDB持久化完成，生产环境慎用
      - bgsave：fork()一个子进程执行持久化，整个过程只在fork子进程时短暂阻塞，当子进程被创建之后，Redis主进程就可以相应请求了
   - 自动触发
      - save m n 配置：m秒内，有n个键发生变化时，触发
      - flushall:清空Redis数据库，触发RDB持久化
      - 主从同步触发

优点：

- 备份频率设置灵活
- 适合冷备份，灾难恢复
- 对服务进程影响较小
- 速度快，大数据下比AOF更快

缺点：

- 无法避免数据丢失，数据精确性不够高
- 当数据过多时，会影响服务进程（建议夜晚持久化）

#####AOF只追加文件
每执行一条命令，就将命令写入AOF文件中

- 简单过程：将命令写入缓冲区->根据策略刷新到原先AOF文件中
   - 刷新策略：1.每条命令刷新一次 2.每秒刷新一次 3.由系统决定什么时候刷新
- AOF文件重写过程：fork子进程->全量遍历内存数据（不是基于已有的AOF文件）-->与此同时，新修改的命令同时写入aof缓冲区和重写缓冲区->重写之后把数据刷回新的aof文件中->替换旧aof文件

优点：

- 更高的数据准确性
- 采用追加方式，服务宕机时不会影响已持久化内容
- 日志重写，整理出的日志便于理解

缺点：

- 同等数据下，AOF比RDB更大，恢复更慢
- 效率慢于RDB
- 存在一定bug的可能性，不稳定

