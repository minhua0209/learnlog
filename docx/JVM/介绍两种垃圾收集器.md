##介绍两种垃圾收集器
###CMS收集器
CMS收集器是一种**以获取最短回收停顿时间为目标的收集器。**

CMS收集器基于”标记-清除“算法实现，整个过程可分为四个步骤：

- 初始标记
- 并发标记
- 重新标记
- 并发清除

其中初始标记，重新标记仍然需要停顿。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；并发标记就是 GC Roots Tracing 的过程；而重新标记阶段则是为了修改并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记稍长，但远比并发标记时间短。

CMS是一款优秀的收集器，**优点明显**：

1. 并发收集
2. 低停顿

但它还有3个明显的缺点：

1. **CMS收集器对CPU资源非常敏感。**在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分线程而导致应用程序变慢，总吞吐量降低。CMS默认启用的回收线程数是(CPU数量 + 3)/4，当CPU在4个以上时，并发回收垃圾时线程占用不少于25%的CPU资源，并随着CPU资源增加而减少。**但是当CPU不足4个时，CMS对用户程序的影响就会变得很大。**
2. **CMS无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次 Full GC 的产生。**由于CMS并发清理阶段用户线程还在运行，伴随程序运行自然就会产生新的垃圾，这一部分垃圾出现在标记之后，CMS无法在当次收集中处理掉它们，只好在下一次GC时清理，这部分垃圾就是“浮动垃圾”。也是由于垃圾收集阶段用户线程还需运行，也就是**必须预留足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎全被填满之后在进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS在运行期间预留的内存不够，就会出现“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器重新进行老年代垃圾收集，停顿时间会更长。所以说参数 `-XX:CMSInitiatingOccupancyFraction`设置太高容易导致大量的“Concurrent Mode Failure”失败，性能反而降低。**
3. CMS收集器基于“标记-清楚”算法，**会导致大量的空间碎片产生，空间碎片过多时将会触发Full GC,**因此CMS提供一个参数`-XX:+UseCMSCompactAtFullCollection`开关参数，用于在CMS顶不住要进行Full GC时开启内存碎片整理过程，内存整理无法并发，因此停顿变长，所以还有一个参数`-XX:CMSFullGCsBeforeCompaction`用来设置多少次不压缩Full GC后，跟着来一次压缩的。


###G1收集器
G1收集器是当今收集器技术发展最前沿的成果之一。

相较于其他垃圾收集器，它有如下特点：

1. **并行与并发**：充分利用多核的硬件优势缩短停顿时间，G1收集器通过并发方式让Java程序继续运行。
2. **分代收集**：能采用不同的方式去处理新创建的对象和已存活一段时间熬过多次GC的对象。
3. **空间整合**：G1整体看来是基于“标记-整理算法实现”，从局部（两个Region之间）来看是基于“复制”算法实现，因此不会产生空间碎片的问题。
4. **可预测的停顿**：G1除了追求低停顿之后，还建立了可预测停顿时间的模型，能让使用者明确指出在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。

####如何做到可预测停顿时间模型？
**G1收集器不再使用简单的新生代老年代划分，它将整个堆划分为多个大小相等的独立区域（Region），虽然还保留新生代老年代概念，但新生代老年代不在是物理隔离了，是一部分Region的集合。**之所以可以建立时间预测模型是因为他**有计划的避免了在整个堆中进行全区域的垃圾收集**。G1收集器在后台维护了一个优先队列，记录了每个Region里面垃圾堆积的价值大小（回收经验值），保证G1收集器在有限的时间内可以尽可能提高收集效率。

G1基本步骤如下：

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改一下TAMS的值，这阶段需要停顿线程，但耗时很短；并发标记是从 GC Roots开始对对堆中对象进行可达性分析，这阶段耗时较长，但可与用户进程并发执行。而最终标记则是为了修改了在并发标记阶段因程序运行而导致标记产生变化的那部分记录，这阶段需要停顿，但可并发执行。**最后对各个Region以回收价值排序，根据用户要求的GC停顿时间制定执行计划。**
